<section><div><div class="ds gv gw gx gy gz"></div><div class="ha hb hc hd he"><div class=""><h1 id="46df" class="pw-post-title hf hg hh bd hi hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id bi" data-selectable-paragraph="">Easily Validate User-Generated Data Using Pydantic</h1></div><div class=""><h2 id="fb40" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dw" data-selectable-paragraph="">How to us Pydantic to validate Excel data</h2></div><figure class="ix iy iz ja fc jb eq er paragraph-image"><div class="eq er iw"><picture><source srcset="https://miro.medium.com/v2/resize:fit:640/format:webp/0*VbkyVFmO_sZIJUWp.jpg 640w, https://miro.medium.com/v2/resize:fit:720/format:webp/0*VbkyVFmO_sZIJUWp.jpg 720w, https://miro.medium.com/v2/resize:fit:750/format:webp/0*VbkyVFmO_sZIJUWp.jpg 750w, https://miro.medium.com/v2/resize:fit:786/format:webp/0*VbkyVFmO_sZIJUWp.jpg 786w, https://miro.medium.com/v2/resize:fit:828/format:webp/0*VbkyVFmO_sZIJUWp.jpg 828w, https://miro.medium.com/v2/resize:fit:1100/format:webp/0*VbkyVFmO_sZIJUWp.jpg 1100w, https://miro.medium.com/v2/resize:fit:1280/format:webp/0*VbkyVFmO_sZIJUWp.jpg 1280w" sizes="(min-resolution: 4dppx) and (max-width: 700px) 50vw, (-webkit-min-device-pixel-ratio: 4) and (max-width: 700px) 50vw, (min-resolution: 3dppx) and (max-width: 700px) 67vw, (-webkit-min-device-pixel-ratio: 3) and (max-width: 700px) 65vw, (min-resolution: 2.5dppx) and (max-width: 700px) 80vw, (-webkit-min-device-pixel-ratio: 2.5) and (max-width: 700px) 80vw, (min-resolution: 2dppx) and (max-width: 700px) 100vw, (-webkit-min-device-pixel-ratio: 2) and (max-width: 700px) 100vw, 640px" type="image/webp"><source data-testid="og" srcset="https://miro.medium.com/v2/resize:fit:640/0*VbkyVFmO_sZIJUWp.jpg 640w, https://miro.medium.com/v2/resize:fit:720/0*VbkyVFmO_sZIJUWp.jpg 720w, https://miro.medium.com/v2/resize:fit:750/0*VbkyVFmO_sZIJUWp.jpg 750w, https://miro.medium.com/v2/resize:fit:786/0*VbkyVFmO_sZIJUWp.jpg 786w, https://miro.medium.com/v2/resize:fit:828/0*VbkyVFmO_sZIJUWp.jpg 828w, https://miro.medium.com/v2/resize:fit:1100/0*VbkyVFmO_sZIJUWp.jpg 1100w, https://miro.medium.com/v2/resize:fit:1280/0*VbkyVFmO_sZIJUWp.jpg 1280w" sizes="(min-resolution: 4dppx) and (max-width: 700px) 50vw, (-webkit-min-device-pixel-ratio: 4) and (max-width: 700px) 50vw, (min-resolution: 3dppx) and (max-width: 700px) 67vw, (-webkit-min-device-pixel-ratio: 3) and (max-width: 700px) 65vw, (min-resolution: 2.5dppx) and (max-width: 700px) 80vw, (-webkit-min-device-pixel-ratio: 2.5) and (max-width: 700px) 80vw, (min-resolution: 2dppx) and (max-width: 700px) 100vw, (-webkit-min-device-pixel-ratio: 2) and (max-width: 700px) 100vw, 640px"><img alt="" class="bf jc jd c" width="640" height="800" loading="eager" role="presentation" src="https://miro.medium.com/max/800/0*VbkyVFmO_sZIJUWp.jpg"></picture></div><figcaption class="je jf es eq er jg jh bd b be z dw" data-selectable-paragraph="">Photo by <a class="ae ji" href="https://unsplash.com/@deepmind?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">DeepMind</a> on <a class="ae ji" href="https://unsplash.com/photos/oVm12cylnBw?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="f714" class="jj jk hh bd jl jm jn jo jp jq jr js jt in ju io jv iq jw ir jx it jy iu jz ka bi" data-selectable-paragraph="">Using Pydantic to validate Excel data</h1><p id="bb2e" class="pw-post-body-paragraph kb kc hh kd b ke kf ii kg kh ki il kj kk kl km kn ko kp kq kr ks kt ku kv kw ha bi" data-selectable-paragraph="">As a data engineer, I frequently encounter situations where I have built pipelines and other automations based on user-generated data from Excel. Excel’s flexibility allows it to be used by a wide variety of users, but unfortunately, that flexibility leads to invalid data entering the pipeline. Before I discovered Pydantic, I wrote incredibly complex Pandas functions to check and filter data to make sure it was valid.</p><h1 id="5d1f" class="jj jk hh bd jl jm jn jo jp jq jr js jt in ju io jv iq jw ir jx it jy iu jz ka bi" data-selectable-paragraph="">What is Pydantic?</h1><p id="da8c" class="pw-post-body-paragraph kb kc hh kd b ke kf ii kg kh ki il kj kk kl km kn ko kp kq kr ks kt ku kv kw ha bi" data-selectable-paragraph="">Pydantic is a Python library that lets you define a data model in a Pythonic way, and use that model to validate data inputs, mainly through using type hints.</p><h1 id="f41b" class="jj jk hh bd jl jm jn jo jp jq jr js jt in ju io jv iq jw ir jx it jy iu jz ka bi" data-selectable-paragraph="">Sample data:</h1><p id="4a8e" class="pw-post-body-paragraph kb kc hh kd b ke kf ii kg kh ki il kj kk kl km kn ko kp kq kr ks kt ku kv kw ha bi" data-selectable-paragraph="">Before we get going, let’s examine our sample data; a spreadsheet of RPG characters I created using random name generators:</p><figure class="ix iy iz ja fc jb eq er paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="eq er kx"><picture><source srcset="https://miro.medium.com/v2/resize:fit:640/format:webp/1*4s6QDAQeZAWHTkDzivanVw.png 640w, https://miro.medium.com/v2/resize:fit:720/format:webp/1*4s6QDAQeZAWHTkDzivanVw.png 720w, https://miro.medium.com/v2/resize:fit:750/format:webp/1*4s6QDAQeZAWHTkDzivanVw.png 750w, https://miro.medium.com/v2/resize:fit:786/format:webp/1*4s6QDAQeZAWHTkDzivanVw.png 786w, https://miro.medium.com/v2/resize:fit:828/format:webp/1*4s6QDAQeZAWHTkDzivanVw.png 828w, https://miro.medium.com/v2/resize:fit:1100/format:webp/1*4s6QDAQeZAWHTkDzivanVw.png 1100w, https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4s6QDAQeZAWHTkDzivanVw.png 1400w" sizes="(min-resolution: 4dppx) and (max-width: 700px) 50vw, (-webkit-min-device-pixel-ratio: 4) and (max-width: 700px) 50vw, (min-resolution: 3dppx) and (max-width: 700px) 67vw, (-webkit-min-device-pixel-ratio: 3) and (max-width: 700px) 65vw, (min-resolution: 2.5dppx) and (max-width: 700px) 80vw, (-webkit-min-device-pixel-ratio: 2.5) and (max-width: 700px) 80vw, (min-resolution: 2dppx) and (max-width: 700px) 100vw, (-webkit-min-device-pixel-ratio: 2) and (max-width: 700px) 100vw, 700px" type="image/webp"><source data-testid="og" srcset="https://miro.medium.com/v2/resize:fit:640/1*4s6QDAQeZAWHTkDzivanVw.png 640w, https://miro.medium.com/v2/resize:fit:720/1*4s6QDAQeZAWHTkDzivanVw.png 720w, https://miro.medium.com/v2/resize:fit:750/1*4s6QDAQeZAWHTkDzivanVw.png 750w, https://miro.medium.com/v2/resize:fit:786/1*4s6QDAQeZAWHTkDzivanVw.png 786w, https://miro.medium.com/v2/resize:fit:828/1*4s6QDAQeZAWHTkDzivanVw.png 828w, https://miro.medium.com/v2/resize:fit:1100/1*4s6QDAQeZAWHTkDzivanVw.png 1100w, https://miro.medium.com/v2/resize:fit:1400/1*4s6QDAQeZAWHTkDzivanVw.png 1400w" sizes="(min-resolution: 4dppx) and (max-width: 700px) 50vw, (-webkit-min-device-pixel-ratio: 4) and (max-width: 700px) 50vw, (min-resolution: 3dppx) and (max-width: 700px) 67vw, (-webkit-min-device-pixel-ratio: 3) and (max-width: 700px) 65vw, (min-resolution: 2.5dppx) and (max-width: 700px) 80vw, (-webkit-min-device-pixel-ratio: 2.5) and (max-width: 700px) 80vw, (min-resolution: 2dppx) and (max-width: 700px) 100vw, (-webkit-min-device-pixel-ratio: 2) and (max-width: 700px) 100vw, 700px"><img alt="" class="bf jc jd c" width="700" height="242" loading="lazy" role="presentation" src="https://miro.medium.com/max/875/1*4s6QDAQeZAWHTkDzivanVw.png"></picture></div></div><figcaption class="je jf es eq er jg jh bd b be z dw" data-selectable-paragraph="">Image by Author</figcaption></figure><p id="ff8e" class="pw-post-body-paragraph kb kc hh kd b ke lc ii kg kh ld il kj kk le km kn ko lf kq kr ks lg ku kv kw ha bi" data-selectable-paragraph="">Column headers in bold indicate required fields, and we can see that some of the required fields are missing. Also, some of our text fields, like <code class="dt lh li lj lk b">Race</code>, <code class="dt lh li lj lk b">Class</code> and <code class="dt lh li lj lk b">Gender</code> should be restricted to specific words instead of being free-text fields.</p><h1 id="f4c0" class="jj jk hh bd jl jm jn jo jp jq jr js jt in ju io jv iq jw ir jx it jy iu jz ka bi" data-selectable-paragraph="">Starting our data model</h1><p id="a926" class="pw-post-body-paragraph kb kc hh kd b ke kf ii kg kh ki il kj kk kl km kn ko kp kq kr ks kt ku kv kw ha bi" data-selectable-paragraph="">Pydantic has a number of starting points for a data model, but ours is pretty simple so we are going to use <code class="dt lh li lj lk b">pydantic.BaseMode</code> l:</p><pre class="ix iy iz ja fc ll lk lm bn ln lo bi"><span id="bce7" class="lp jk hh lk b be lq lr l ls lt" data-selectable-paragraph=""><span class="hljs-keyword">import</span> pydantic<br><br><span class="hljs-keyword">class</span> <span class="hljs-title.class">RpgCharacterModel</span>(pydantic.BaseModel):<br>    DATE: datetime<br>    NAME: <span class="hljs-built_in">str</span><br>    GENDER: <span class="hljs-built_in">str</span><br>    RACE: <span class="hljs-built_in">str</span><br>    CLASS: <span class="hljs-built_in">str</span><br>    HOME: <span class="hljs-built_in">str</span><br>    GUILD: <span class="hljs-built_in">str</span><br>    PAY: <span class="hljs-built_in">int</span></span></pre><p id="6e01" class="pw-post-body-paragraph kb kc hh kd b ke lc ii kg kh ld il kj kk le km kn ko lf kq kr ks lg ku kv kw ha bi" data-selectable-paragraph="">The syntax is pretty simple. After defining the class and inheriting from our base model, we enter each of our field names and provide a type hint.</p><p id="0c94" class="pw-post-body-paragraph kb kc hh kd b ke lc ii kg kh ld il kj kk le km kn ko lf kq kr ks lg ku kv kw ha bi" data-selectable-paragraph="">While this is a good start, this model has some severe limitations. Right now it will accept any string for a number of fields that we would prefer to be restricted to certain values.</p><h1 id="0d81" class="jj jk hh bd jl jm jn jo jp jq jr js jt in ju io jv iq jw ir jx it jy iu jz ka bi" data-selectable-paragraph="">Enums to control string fields</h1><p id="0b8d" class="pw-post-body-paragraph kb kc hh kd b ke kf ii kg kh ki il kj kk kl km kn ko kp kq kr ks kt ku kv kw ha bi" data-selectable-paragraph="">Type hints in Pydantic are more powerful when working with other class types in Python. One of these powerful features is being able to limit string entries by defining Enums and passing the Enum as a type hint.</p><p id="b6b5" class="pw-post-body-paragraph kb kc hh kd b ke lc ii kg kh ld il kj kk le km kn ko lf kq kr ks lg ku kv kw ha bi" data-selectable-paragraph="">Now we define those choices as Enums:</p><pre class="ix iy iz ja fc ll lk lm bn ln lo bi"><span id="520c" class="lp jk hh lk b be lq lr l ls lt" data-selectable-paragraph=""><span class="hljs-keyword">import</span> enum<br><br><span class="hljs-keyword">class</span> <span class="hljs-title.class">GenderEnum</span>(enum.Enum):<br>    M = <span class="hljs-string">'M'</span><br>    F = <span class="hljs-string">'F'</span><br>    NB = <span class="hljs-string">'NB'</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title.class">ClassEnum</span>(enum.Enum):<br>    Druid = <span class="hljs-string">'Druid'</span><br>    Fighter = <span class="hljs-string">'Fighter'</span><br>    Warlock = <span class="hljs-string">'Warlock'</span><br>    Ranger = <span class="hljs-string">'Ranger'</span><br>    Bard = <span class="hljs-string">'Bard'</span><br>    Sorcerer = <span class="hljs-string">'Sorcerer'</span><br>    Paladin = <span class="hljs-string">'Paladin'</span><br>    Rogue = <span class="hljs-string">'Rogue'</span><br>    Wizard = <span class="hljs-string">'Wizard'</span><br>    Monk = <span class="hljs-string">'Monk'</span><br>    Barbarian = <span class="hljs-string">'Barbarian'</span><br>    Cleric = <span class="hljs-string">'Cleric'</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title.class">RaceEnum</span>(enum.Enum):<br>    Human = <span class="hljs-string">'Human'</span><br>    Dwarf = <span class="hljs-string">'Dwarf'</span><br>    Halfling = <span class="hljs-string">'Halfling'</span><br>    Elf = <span class="hljs-string">'Elf'</span><br>    Dragonborn = <span class="hljs-string">'Dragonborn'</span><br>    Tiefling = <span class="hljs-string">'Tiefling'</span><br>    Half_Orc = <span class="hljs-string">'Half-Orc'</span><br>    Gnome = <span class="hljs-string">'Gnome'</span><br>    Half_Elf = <span class="hljs-string">'Half-Elf'</span></span></pre><p id="b244" class="pw-post-body-paragraph kb kc hh kd b ke lc ii kg kh ld il kj kk le km kn ko lf kq kr ks lg ku kv kw ha bi" data-selectable-paragraph="">Now, we can use these enums to be much more specific with our data model:</p><pre class="ix iy iz ja fc ll lk lm bn ln lo bi"><span id="cbbd" class="lp jk hh lk b be lq lr l ls lt" data-selectable-paragraph=""><span class="hljs-keyword">class</span> <span class="hljs-title.class">RpgCharacterModel</span>(pydantic.BaseModel):<br>    DATE: datetime<br>    NAME: <span class="hljs-built_in">str</span><br>    GENDER: GenderEnum<br>    RACE: RaceEnum<br>    CLASS: ClassEnum<br>    HOME: <span class="hljs-built_in">str</span><br>    GUILD: <span class="hljs-built_in">str</span><br>    PAY: <span class="hljs-built_in">int</span></span></pre><p id="6c81" class="pw-post-body-paragraph kb kc hh kd b ke lc ii kg kh ld il kj kk le km kn ko lf kq kr ks lg ku kv kw ha bi" data-selectable-paragraph="">Our data model is looking better, but there are two more things we need to do to really tighten it up.</p><ol class=""><li id="b64b" class="lu lv hh kd b ke lc kh ld kk lw ko lx ks ly kw lz ma mb mc bi" data-selectable-paragraph="">Specify required fields</li><li id="0aff" class="lu lv hh kd b ke md kh me kk mf ko mg ks mh kw lz ma mb mc bi" data-selectable-paragraph="">Specify a range for pay. Numbers are a common place for data entry mistakes</li></ol><p id="9356" class="pw-post-body-paragraph kb kc hh kd b ke lc ii kg kh ld il kj kk le km kn ko lf kq kr ks lg ku kv kw ha bi" data-selectable-paragraph="">Pydantic offers an optional function that lets us define even more specificity in our data model.</p><h1 id="aba8" class="jj jk hh bd jl jm jn jo jp jq jr js jt in ju io jv iq jw ir jx it jy iu jz ka bi" data-selectable-paragraph="">Field() for even greater specificity.</h1><p id="6e63" class="pw-post-body-paragraph kb kc hh kd b ke kf ii kg kh ki il kj kk kl km kn ko kp kq kr ks kt ku kv kw ha bi" data-selectable-paragraph="">When defining a field in our data model, we can call the function Field() to specify additional options, including whether or not a field is required, and setting up limitations on numeric inputs.</p><pre class="ix iy iz ja fc ll lk lm bn ln lo bi"><span id="b9ef" class="lp jk hh lk b be lq lr l ls lt" data-selectable-paragraph=""><span class="hljs-string">import</span> <span class="hljs-string">pydantic</span><br><br><span class="hljs-string">class</span> <span class="hljs-string">RpgCharacterModel(pydantic.BaseModel):</span><br>    <span class="hljs-attr">DATE:</span> <span class="hljs-string">datetime</span><br>    <span class="hljs-attr">NAME:</span> <span class="hljs-string">str</span> <span class="hljs-string">=</span> <span class="hljs-string">pydantic.Field(...)</span><br>    <span class="hljs-attr">GENDER:</span> <span class="hljs-string">GenderEnum</span><br>    <span class="hljs-attr">RACE:</span> <span class="hljs-string">RaceEnum</span> <span class="hljs-string">=</span> <span class="hljs-string">pydantic.Field(...)</span><br>    <span class="hljs-attr">CLASS:</span> <span class="hljs-string">ClassEnum</span> <span class="hljs-string">=</span> <span class="hljs-string">pydantic.Field(...)</span><br>    <span class="hljs-attr">HOME:</span> <span class="hljs-string">str</span><br>    <span class="hljs-attr">GUILD:</span> <span class="hljs-string">str</span><br>    <span class="hljs-attr">PAY:</span> <span class="hljs-string">int</span> <span class="hljs-string">=</span> <span class="hljs-string">pydantic.Field(...,</span> <span class="hljs-string">ge=1,</span> <span class="hljs-string">le=500)</span></span></pre><p id="0eec" class="pw-post-body-paragraph kb kc hh kd b ke lc ii kg kh ld il kj kk le km kn ko lf kq kr ks lg ku kv kw ha bi" data-selectable-paragraph="">Passing <code class="dt lh li lj lk b">...</code> as the first argument to Field indicates that it is required.</p><ul class=""><li id="8fb8" class="lu lv hh kd b ke lc kh ld kk lw ko lx ks ly kw mi ma mb mc bi" data-selectable-paragraph="">the <code class="dt lh li lj lk b">ge</code> keyword means <code class="dt lh li lj lk b">Greater than or equal to</code></li><li id="d4c2" class="lu lv hh kd b ke md kh me kk mf ko mg ks mh kw mi ma mb mc bi" data-selectable-paragraph="">the <code class="dt lh li lj lk b">le</code> keyword means <code class="dt lh li lj lk b">Less than or equal to</code></li></ul><h1 id="34b1" class="jj jk hh bd jl jm jn jo jp jq jr js jt in ju io jv iq jw ir jx it jy iu jz ka bi" data-selectable-paragraph="">Using the model</h1><p id="4b17" class="pw-post-body-paragraph kb kc hh kd b ke kf ii kg kh ki il kj kk kl km kn ko kp kq kr ks kt ku kv kw ha bi" data-selectable-paragraph="">Now we’ve done all the work to define the model, we need to use it.</p><p id="e002" class="pw-post-body-paragraph kb kc hh kd b ke lc ii kg kh ld il kj kk le km kn ko lf kq kr ks lg ku kv kw ha bi" data-selectable-paragraph="">Pydantic models expect to receive JSON-like data, so any data we pass to our model for validation must be a dictionary.</p><p id="e9a2" class="pw-post-body-paragraph kb kc hh kd b ke lc ii kg kh ld il kj kk le km kn ko lf kq kr ks lg ku kv kw ha bi" data-selectable-paragraph="">For our data validation, we need to do the following:</p><ul class=""><li id="6ca5" class="lu lv hh kd b ke lc kh ld kk lw ko lx ks ly kw mi ma mb mc bi" data-selectable-paragraph="">Receive a DataFrame as an input</li><li id="6635" class="lu lv hh kd b ke md kh me kk mf ko mg ks mh kw mi ma mb mc bi" data-selectable-paragraph="">Convert it to a list of dictionaries (one dictionary per row)</li><li id="051c" class="lu lv hh kd b ke md kh me kk mf ko mg ks mh kw mi ma mb mc bi" data-selectable-paragraph="">Run each row through data validation</li><li id="4c1e" class="lu lv hh kd b ke md kh me kk mf ko mg ks mh kw mi ma mb mc bi" data-selectable-paragraph="">Append successfully validated rows to one list</li><li id="3e5d" class="lu lv hh kd b ke md kh me kk mf ko mg ks mh kw mi ma mb mc bi" data-selectable-paragraph="">Append failed rows to another list, with the row number and the error message</li></ul><pre class="ix iy iz ja fc ll lk lm bn ln lo bi"><span id="bcdc" class="lp jk hh lk b be lq lr l ls lt" data-selectable-paragraph=""><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> pydantic<br><br><span class="hljs-keyword">def</span> <span class="hljs-title.function">validate_df_data</span>(<span class="hljs-params">df: pd.DataFrame, model: pydantic.BaseModel, index_offset: <span class="hljs-built_in">int</span> = <span class="hljs-number">2</span></span>) -&gt; <span class="hljs-built_in">tuple</span>[<span class="hljs-built_in">list</span>, <span class="hljs-built_in">list</span>]:<br>    <span class="hljs-comment"># Python index starts at 0, excel at 1, and 1 row for the header in Excel</span><br><br>    <span class="hljs-comment">#capturing our good data and our bad data</span><br>    good_data = []<br>    bad_data = []<br>    df_rows = df.to_dict(orient=<span class="hljs-string">'records'</span>)<br>    <span class="hljs-keyword">for</span> index, row <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(df_rows):<br>        <span class="hljs-keyword">try</span>:<br>            model(**row)  <span class="hljs-comment">#unpacks our dictionary into our keyword arguments</span><br>            good_data.append(row)  <span class="hljs-comment">#appends valid data to a new list of dictionaries</span><br>        <span class="hljs-keyword">except</span> pydantic.ValidationError <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-comment"># Adds all validation error messages associated with the error</span><br>            <span class="hljs-comment"># and adds them to the dictionary</span><br>            row[<span class="hljs-string">'Errors'</span>] = [error_message[<span class="hljs-string">'msg'</span>] <span class="hljs-keyword">for</span> error_message <span class="hljs-keyword">in</span> e.errors()]<br><br>            row[<span class="hljs-string">'Error_row_num'</span>] = index + index_offset<br>            bad_data.append(row)  <span class="hljs-comment">#appends bad data to a different list of dictionaries</span><br><br>    <span class="hljs-keyword">return</span> (good_data, bad_data)</span></pre><p id="f57f" class="pw-post-body-paragraph kb kc hh kd b ke lc ii kg kh ld il kj kk le km kn ko lf kq kr ks lg ku kv kw ha bi" data-selectable-paragraph="">Using this function, we can process the good rows of data, and return the bad rows of data for QA, modification, and resubmission.</p><h1 id="df1b" class="jj jk hh bd jl jm jn jo jp jq jr js jt in ju io jv iq jw ir jx it jy iu jz ka bi" data-selectable-paragraph="">Full code</h1><pre class="ix iy iz ja fc ll lk lm bn ln lo bi"><span id="2dba" class="lp jk hh lk b be lq lr l ls lt" data-selectable-paragraph=""><span class="hljs-comment"># Standard Library imports</span><br><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><span class="hljs-keyword">import</span> enum<br><br><span class="hljs-comment"># 3rd Party package imports</span><br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> pydantic<br><br><span class="hljs-comment"># Enums for limiting string data in our model</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title.class">GenderEnum</span>(enum.Enum):<br>    M = <span class="hljs-string">'M'</span><br>    F = <span class="hljs-string">'F'</span><br>    NB = <span class="hljs-string">'NB'</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title.class">ClassEnum</span>(enum.Enum):<br>    Druid = <span class="hljs-string">'Druid'</span><br>    Fighter = <span class="hljs-string">'Fighter'</span><br>    Warlock = <span class="hljs-string">'Warlock'</span><br>    Ranger = <span class="hljs-string">'Ranger'</span><br>    Bard = <span class="hljs-string">'Bard'</span><br>    Sorcerer = <span class="hljs-string">'Sorcerer'</span><br>    Paladin = <span class="hljs-string">'Paladin'</span><br>    Rogue = <span class="hljs-string">'Rogue'</span><br>    Wizard = <span class="hljs-string">'Wizard'</span><br>    Monk = <span class="hljs-string">'Monk'</span><br>    Barbarian = <span class="hljs-string">'Barbarian'</span><br>    Cleric = <span class="hljs-string">'Cleric'</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title.class">RaceEnum</span>(enum.Enum):<br>    Human = <span class="hljs-string">'Human'</span><br>    Dwarf = <span class="hljs-string">'Dwarf'</span><br>    Halfling = <span class="hljs-string">'Halfling'</span><br>    Elf = <span class="hljs-string">'Elf'</span><br>    Dragonborn = <span class="hljs-string">'Dragonborn'</span><br>    Tiefling = <span class="hljs-string">'Tiefling'</span><br>    Half_Orc = <span class="hljs-string">'Half-Orc'</span><br>    Gnome = <span class="hljs-string">'Gnome'</span><br>    Half_Elf = <span class="hljs-string">'Half-Elf'</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title.class">RpgCharacterModel</span>(pydantic.BaseModel):<br>    DATE: datetime<br>    NAME: <span class="hljs-built_in">str</span> = pydantic.Field(...)<br>    GENDER: GenderEnum<br>    RACE: RaceEnum = pydantic.Field(...)<br>    CLASS: ClassEnum = pydantic.Field(...)<br>    HOME: <span class="hljs-built_in">str</span><br>    GUILD: <span class="hljs-built_in">str</span><br>    PAY: <span class="hljs-built_in">int</span> = pydantic.Field(..., ge=<span class="hljs-number">1</span>, le=<span class="hljs-number">500</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title.function">validate_df_data</span>(<span class="hljs-params">df: pd.DataFrame, model: pydantic.BaseModel, index_offset: <span class="hljs-built_in">int</span> = <span class="hljs-number">2</span></span>) -&gt; <span class="hljs-built_in">tuple</span>[<span class="hljs-built_in">list</span>, <span class="hljs-built_in">list</span>]:<br>    <span class="hljs-comment"># Python index starts at 0, excel at 1, and 1 row for the header in Excel</span><br><br>    <span class="hljs-comment">#capturing our good data and our bad data</span><br>    good_data = []<br>    bad_data = []<br>    df_rows = df.to_dict(orient=<span class="hljs-string">'records'</span>)<br>    <span class="hljs-keyword">for</span> index, row <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(df_rows):<br>        <span class="hljs-keyword">try</span>:<br>            model(**row)  <span class="hljs-comment">#unpacks our dictionary into our keyword arguments</span><br>            good_data.append(row)  <span class="hljs-comment">#appends valid data to a new list of dictionaries</span><br>        <span class="hljs-keyword">except</span> pydantic.ValidationError <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-comment"># Adds all validation error messages associated with the error</span><br>            <span class="hljs-comment"># and adds them to the dictionary</span><br>            row[<span class="hljs-string">'Errors'</span>] = [error_message[<span class="hljs-string">'msg'</span>] <span class="hljs-keyword">for</span> error_message <span class="hljs-keyword">in</span> e.errors()]<br>            <span class="hljs-comment"># Python index starts at 0, excel at 1, and 1 row for the header in excel</span><br>            row[<span class="hljs-string">'Error_row_num'</span>] = index + index_offset<br>            bad_data.append(row)  <span class="hljs-comment">#appends bad data to a different list of dictionaries</span><br><br>    <span class="hljs-keyword">return</span> (good_data, bad_data)<br><br>df = pd.read_excel(<span class="hljs-string">'sample_dnd_character_data.xlsx'</span>)<br>valid_data, invalid_data = validate_df_data(df, RpgCharacterModel, index_offset=<span class="hljs-number">2</span>)</span></pre><p id="5510" class="pw-post-body-paragraph kb kc hh kd b ke lc ii kg kh ld il kj kk le km kn ko lf kq kr ks lg ku kv kw ha bi" data-selectable-paragraph="">All code plus sample data can be found in my <a class="ae ji" href="https://github.com/Carobert85/pydantic_data_validation" rel="noopener ugc nofollow" target="_blank">GitHub repo</a></p><h1 id="1dff" class="jj jk hh bd jl jm jn jo jp jq jr js jt in ju io jv iq jw ir jx it jy iu jz ka bi" data-selectable-paragraph="">Conclusion and next steps</h1><p id="7b54" class="pw-post-body-paragraph kb kc hh kd b ke kf ii kg kh ki il kj kk kl km kn ko kp kq kr ks kt ku kv kw ha bi" data-selectable-paragraph="">Pydantic is exceptionally powerful, and while this was a simple example, it can handle complex nested models. This really allows a lot of granularity with data validation without writing a ton of code.</p><p id="fe03" class="pw-post-body-paragraph kb kc hh kd b ke lc ii kg kh ld il kj kk le km kn ko lf kq kr ks lg ku kv kw ha bi" data-selectable-paragraph="">As an additional benefit, modeling the data really helps you understand it, rather than just taking whatever is thrown at you.</p><p id="cf7a" class="pw-post-body-paragraph kb kc hh kd b ke lc ii kg kh ld il kj kk le km kn ko lf kq kr ks lg ku kv kw ha bi" data-selectable-paragraph="">While this tutorial focused on Pandas, you can use Pydantic to validate most forms of data inputs with Python.</p></div></section>
